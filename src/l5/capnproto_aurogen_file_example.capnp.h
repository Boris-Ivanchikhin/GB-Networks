// Это **часть** сгенерированного файла.

// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: tag.capnp

#ifndef CAPNP_INCLUDED_bed3aeae4f107525_
#define CAPNP_INCLUDED_bed3aeae4f107525_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(a46725f1a072r569);
CAPNP_DECLARE_SCHEMA(92a278363ebd4fb6);
enum class Type_104324d324faf34feac: uint16_t {
  READ,
  WRITE,
};
CAPNP_DECLARE_ENUM(Type, 104324d324faf34feac);
CAPNP_DECLARE_SCHEMA(b2312312313);
CAPNP_DECLARE_SCHEMA(e343243e2441);
CAPNP_DECLARE_SCHEMA(21242efafbc);
CAPNP_DECLARE_SCHEMA(a24243fcae436e);

}  // namespace schemas
}  // namespace capnp

namespace our_system {
namespace capnp {

struct Tag {
  Tag() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_104324d324faf34feac Type;

  struct Value;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7686a996e96b96, 5, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Tag::Value {
  Value() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    INT,
    DOUBLE,
    STRING,
    BOOL,
    LIST,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(5a6788bc86ed86, 5, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Tag::Reader {
public:
  typedef Tag Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId() const;

  inline  ::uint64_t getTimestamp() const;

  inline  ::uint64_t getRecvTimestamp() const;

  inline typename Value::Reader getValue() const;

  inline  ::our_system::capnp::Tag::Type getOperation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Tag::Builder {
public:
  typedef Tag Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline  ::uint64_t getRecvTimestamp();
  inline void setRecvTimestamp( ::uint64_t value);

  inline typename Value::Builder getValue();
  inline typename Value::Builder initValue();

  inline  ::our_system::capnp::Tag::Type getOperation();
  inline void setOperation( ::our_system::capnp::Tag::Type value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Tag::Pipeline {
public:
  typedef Tag Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Value::Pipeline getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Tag::Value::Reader {
public:
  typedef Value Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isInt() const;
  inline  ::int64_t getInt() const;

  inline bool isDouble() const;
  inline double getDouble() const;

  inline bool isString() const;
  inline bool hasString() const;
  inline  ::capnp::Text::Reader getString() const;

  inline bool isBool() const;
  inline bool getBool() const;

  inline bool isList() const;
  inline bool hasList() const;
  inline  ::capnp::List< ::uint8_t>::Reader getList() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Tag::Value::Builder {
public:
  typedef Value Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isInt();
  inline  ::int64_t getInt();
  inline void setInt( ::int64_t value);

  inline bool isDouble();
  inline double getDouble();
  inline void setDouble(double value);

  inline bool isString();
  inline bool hasString();
  inline  ::capnp::Text::Builder getString();
  inline void setString( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initString(unsigned int size);
  inline void adoptString(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownString();

  inline bool isBool();
  inline bool getBool();
  inline void setBool(bool value);

  inline bool isList();
  inline bool hasList();
  inline  ::capnp::List< ::uint8_t>::Builder getList();
  inline void setList( ::capnp::List< ::uint8_t>::Reader value);
  inline void setList(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t>::Builder initList(unsigned int size);
  inline void adoptList(::capnp::Orphan< ::capnp::List< ::uint8_t>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t>> disownList();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Tag::Value::Pipeline {
public:
  typedef Value Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint64_t Tag::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Tag::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Tag::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Tag::Reader::getTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Tag::Builder::getTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Tag::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t Tag::Reader::getRecvTimestamp() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Tag::Builder::getRecvTimestamp() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Tag::Builder::setRecvTimestamp( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline typename Tag::Value::Reader Tag::Reader::getValue() const {
  return typename Tag::Value::Reader(_reader);
}
inline typename Tag::Value::Builder Tag::Builder::getValue() {
  return typename Tag::Value::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Tag::Value::Pipeline Tag::Pipeline::getValue() {
  return typename Tag::Value::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Tag::Value::Builder Tag::Builder::initValue() {
  _builder.setDataField< ::uint64_t>(::capnp::bounded<3>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<16>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Tag::Value::Builder(_builder);
}
inline  ::our_system::capnp::Tag::Type Tag::Reader::getOperation() const {
  return _reader.getDataField< ::our_system::capnp::Tag::Type>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}

inline  ::our_system::capnp::Tag::Type Tag::Builder::getOperation() {
  return _builder.getDataField< ::our_system::capnp::Tag::Type>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS);
}
inline void Tag::Builder::setOperation( ::our_system::capnp::Tag::Type value) {
  _builder.setDataField< ::our_system::capnp::Tag::Type>(
      ::capnp::bounded<17>() * ::capnp::ELEMENTS, value);
}

inline  ::our_system::capnp::Tag::Value::Which Tag::Value::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline  ::our_system::capnp::Tag::Value::Which Tag::Value::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Tag::Value::Reader::isInt() const {
  return which() == Tag::Value::INT;
}
inline bool Tag::Value::Builder::isInt() {
  return which() == Tag::Value::INT;
}
inline  ::int64_t Tag::Value::Reader::getInt() const {
  KJ_IREQUIRE((which() == Tag::Value::INT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Tag::Value::Builder::getInt() {
  KJ_IREQUIRE((which() == Tag::Value::INT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Tag::Value::Builder::setInt( ::int64_t value) {
  _builder.setDataField<Tag::Value::Which>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, Tag::Value::INT);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Tag::Value::Reader::isDouble() const {
  return which() == Tag::Value::DOUBLE;
}
inline bool Tag::Value::Builder::isDouble() {
  return which() == Tag::Value::DOUBLE;
}
inline double Tag::Value::Reader::getDouble() const {
  KJ_IREQUIRE((which() == Tag::Value::DOUBLE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double Tag::Value::Builder::getDouble() {
  KJ_IREQUIRE((which() == Tag::Value::DOUBLE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Tag::Value::Builder::setDouble(double value) {
  _builder.setDataField<Tag::Value::Which>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, Tag::Value::DOUBLE);
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Tag::Value::Reader::isString() const {
  return which() == Tag::Value::STRING;
}
inline bool Tag::Value::Builder::isString() {
  return which() == Tag::Value::STRING;
}
inline bool Tag::Value::Reader::hasString() const {
  if (which() != Tag::Value::STRING) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Tag::Value::Builder::hasString() {
  if (which() != Tag::Value::STRING) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}

...

inline  ::capnp::List< ::uint8_t>::Builder Tag::Value::Builder::initList(unsigned int size) {
  _builder.setDataField<Tag::Value::Which>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, Tag::Value::LIST);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Tag::Value::Builder::adoptList(
    ::capnp::Orphan< ::capnp::List< ::uint8_t>>&& value) {
  _builder.setDataField<Tag::Value::Which>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, Tag::Value::LIST);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t>> Tag::Value::Builder::disownList() {
  KJ_IREQUIRE((which() == Tag::Value::LIST),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

#endif  // CAPNP_INCLUDED_bed3aeae4f107525_

